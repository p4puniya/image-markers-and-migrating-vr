Index: src/processing/mode/android/Manifest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* -*- mode: java; c-basic-offset: 2; indent-tabs-mode: nil -*- */\n\n/*\n Part of the Processing project - http://processing.org\n\n Copyright (c) 2012-21 The Processing Foundation\n Copyright (c) 2010-12 Ben Fry and Casey Reas\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License version 2\n as published by the Free Software Foundation.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software Foundation,\n Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\npackage processing.mode.android;\n\nimport org.xml.sax.SAXException;\nimport processing.app.Messages;\nimport processing.app.Sketch;\nimport processing.core.PApplet;\nimport processing.data.XML;\n\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\n\n/**\n * Class encapsulating the manifest file associated with a Processing sketch\n * in the Android mode.\n *\n */\npublic class Manifest {\n  static final String MANIFEST_XML = \"AndroidManifest.xml\";\n\n  static final String MANIFEST_ERROR_TITLE = \"Error handling \" + MANIFEST_XML;\n  static final String MANIFEST_ERROR_MESSAGE =\n    \"Errors occurred while reading or writing \" + MANIFEST_XML + \",\\n\" +\n    \"which means lots of things are likely to stop working properly.\\n\" +\n    \"To prevent losing any data, it's recommended that you use “Save As”\\n\" +\n    \"to save a separate copy of your sketch, and then restart Processing.\";\n  \n  static private final String[] MANIFEST_TEMPLATE = {\n    \"AppManifest.xml.tmpl\",\n    \"WallpaperManifest.xml.tmpl\",\n    \"WatchFaceManifest.xml.tmpl\",\n    \"VRManifest.xml.tmpl\",\n    \"ARManifest.xml.tmpl\"\n  };\n  \n  // Default base package name, user need to change when exporting package. \n  static final String BASE_PACKAGE = \"processing.test\";  \n  \n  static final String PERMISSION_PREFIX = \"android.permission.\";  \n  \n  private Sketch sketch;  \n  private int appComp;  \n  private File modeFolder;\n\n  /** the manifest data read from the file */\n  private XML xml;\n\n\n  public Manifest(Sketch sketch, int appComp, File modeFolder, boolean forceNew) {\n    this.sketch = sketch;\n    this.appComp = appComp;\n    this.modeFolder = modeFolder;\n    load(forceNew);\n  }\n\n\n  private String defaultPackageName() {\n    return BASE_PACKAGE + \".\" + sketch.getName().toLowerCase();\n  }\n\n  \n  private String defaultVersionCode() {\n    return \"1\";\n  }\n\n  \n  private String defaultVersionName() {\n    return \"1.0\";\n  }\n  \n\n  // called by other classes who want an actual package name\n  // internally, we'll figure this out ourselves whether it's filled or not\n  public String getPackageName() {\n    String pkg = xml.getString(\"package\");\n    return pkg.length() == 0 ? defaultPackageName() : pkg;\n  }\n\n\n  public String getVersionCode() {\n    String code = xml.getString(\"android:versionCode\");\n    return code.length() == 0 ? defaultVersionCode() : code;\n  }\n  \n  \n  public String getVersionName() {\n    String name = xml.getString(\"android:versionName\");\n    return name.length() == 0 ? defaultVersionName() : name;\n  }\n  \n  \n  public void setPackageName(String packageName) {\n    xml.setString(\"package\", packageName);\n    save();\n  }\n\n\n  public String[] getPermissions() {\n    XML[] elements = xml.getChildren(\"uses-permission\");\n    int count = elements.length;\n    String[] names = new String[count];\n    for (int i = 0; i < count; i++) {\n      String tmp = elements[i].getString(\"android:name\");\n      if (tmp.indexOf(\"android.permission\") == 0) {\n        // Standard permission, remove prefix\n        int idx = tmp.lastIndexOf(\".\");\n        names[i] = tmp.substring(idx + 1);        \n      } else {\n        // Non-standard permission (for example, wearables)\n        // Store entire name.\n        names[i] = tmp;\n      }\n    }\n    return names;\n  }\n\n\n  public void setPermissions(String[] names) {\n    boolean hasWakeLock = false;\n    boolean hasVibrate = false;\n    boolean hasReadExtStorage = false;\n    boolean hasCameraAccess = false;\n    \n    // Remove all the old permissions...\n    for (XML kid : xml.getChildren(\"uses-permission\")) {\n      String name = kid.getString(\"android:name\");\n      \n      // ...except the ones for watch faces and VR apps.   \n      if (appComp == AndroidBuild.WATCHFACE && name.equals(PERMISSION_PREFIX + \"WAKE_LOCK\")) {\n        hasWakeLock = true;\n        continue;\n      }\n      if (appComp == AndroidBuild.VR && name.equals(PERMISSION_PREFIX + \"VIBRATE\")) {\n        hasVibrate = true;\n        continue;\n      }\n      if (appComp == AndroidBuild.VR && name.equals(PERMISSION_PREFIX + \"READ_EXTERNAL_STORAGE\")) {\n        hasReadExtStorage = true;\n        continue;\n      }\n      if (appComp == AndroidBuild.AR && name.equals(PERMISSION_PREFIX + \"CAMERA\")) {\n        hasCameraAccess = true;\n        continue;\n      }\n      \n      // Don't remove non-standard permissions, such as\n      // com.google.android.wearable.permission.RECEIVE_COMPLICATION_DATA\n      // because these are set manually by the user.\n      if (-1 < name.indexOf(\"com.google.android\")) continue;\n      xml.removeChild(kid);\n    }\n    \n    // ...and add the new permissions back\n    for (String name : names) {\n      \n      // Don't add required permissions for watch faces and VR again...\n      if (appComp == AndroidBuild.WATCHFACE && name.equals(\"WAKE_LOCK\")) continue;\n      if (appComp == AndroidBuild.VR && name.equals(\"VIBRATE\")) continue;\n      if (appComp == AndroidBuild.VR && name.equals(\"READ_EXTERNAL_STORAGE\")) continue;\n      if (appComp == AndroidBuild.AR && name.equals(PERMISSION_PREFIX + \"CAMERA\")) continue;\n         \n      XML newbie = xml.addChild(\"uses-permission\");\n      if (-1 < name.indexOf(\".\")) {\n        // Permission string contains path\n        newbie.setString(\"android:name\", name);\n      } else {\n        newbie.setString(\"android:name\", PERMISSION_PREFIX + name);\n      }\n    }\n\n    // ...unless they were initially missing.\n    if (appComp == AndroidBuild.WATCHFACE && !hasWakeLock) {\n      xml.addChild(\"uses-permission\").\n          setString(\"android:name\", PERMISSION_PREFIX + \"WAKE_LOCK\");\n    }\n    if (appComp == AndroidBuild.VR && !hasVibrate) {\n      xml.addChild(\"uses-permission\").\n          setString(\"android:name\", PERMISSION_PREFIX + \"VIBRATE\");      \n    }\n    if (appComp == AndroidBuild.VR && !hasReadExtStorage) {\n      xml.addChild(\"uses-permission\").\n          setString(\"android:name\", PERMISSION_PREFIX + \"READ_EXTERNAL_STORAGE\");       \n    }\n    if (appComp == AndroidBuild.AR && !hasCameraAccess) {\n      xml.addChild(\"uses-permission\").\n              setString(\"android:name\", PERMISSION_PREFIX + \"CAMERA\");\n    }\n    \n    save();\n  }\n\n  \n  private void fixPermissions(XML mf) {\n    boolean hasWakeLock = false;\n    boolean hasVibrate = false;\n    boolean hasReadExtStorage = false;\n    boolean hasCameraAccess = false;\n    for (XML kid : mf.getChildren(\"uses-permission\")) {\n      String name = kid.getString(\"android:name\");\n      if (appComp == AndroidBuild.WATCHFACE && name.equals(PERMISSION_PREFIX + \"WAKE_LOCK\")) {\n        hasWakeLock = true;\n        continue;\n      }\n      if (appComp == AndroidBuild.VR && name.equals(PERMISSION_PREFIX + \"VIBRATE\")) {\n        hasVibrate = true;\n        continue;\n      }\n      if (appComp == AndroidBuild.VR && name.equals(PERMISSION_PREFIX + \"READ_EXTERNAL_STORAGE\")) {\n        hasReadExtStorage = true;\n        continue;\n      }\n      if (appComp == AndroidBuild.AR && name.equals(PERMISSION_PREFIX + \"CAMERA\")) {\n        hasCameraAccess = true;\n        continue;\n      }\n\n      if (appComp == AndroidBuild.AR && !hasCameraAccess) {\n        mf.addChild(\"uses-permission\").\n                setString(\"android:name\", PERMISSION_PREFIX + \"CAMERA\");\n      }\n    }\n    if (appComp == AndroidBuild.WATCHFACE && !hasWakeLock) {\n      mf.addChild(\"uses-permission\").\n         setString(\"android:name\", PERMISSION_PREFIX + \"WAKE_LOCK\");\n    }\n    if (appComp == AndroidBuild.VR && !hasVibrate) {\n      mf.addChild(\"uses-permission\").\n         setString(\"android:name\", PERMISSION_PREFIX + \"VIBRATE\");      \n    }\n    if (appComp == AndroidBuild.VR && !hasReadExtStorage) {\n      mf.addChild(\"uses-permission\").\n         setString(\"android:name\", PERMISSION_PREFIX + \"READ_EXTERNAL_STORAGE\");       \n    }    \n  }\n  \n\n  private void writeBlankManifest(final File xmlFile, final int appComp) {\n    File xmlTemplate = new File(modeFolder, \"templates/\" + MANIFEST_TEMPLATE[appComp]);    \n    HashMap<String, String> replaceMap = new HashMap<String, String>();    \n    AndroidUtil.createFileFromTemplate(xmlTemplate, xmlFile, replaceMap);\n  }\n\n\n  /**\n   * Save a new version of the manifest info to the build location.\n   * Also fill in any missing attributes that aren't yet set properly.\n   */\n  protected void writeCopy(File file, String className) throws IOException {\n    // write a copy to the build location\n    save(file);\n\n    // load the copy from the build location and start messing with it\n    XML mf = null;\n    try {\n      mf = new XML(file);\n\n      // package name, or default\n      String p = mf.getString(\"package\").trim();\n      if (p.length() == 0) {\n        mf.setString(\"package\", defaultPackageName());\n      }\n\n      // app name and label, or the class name\n      XML app = mf.getChild(\"application\");\n      String label = app.getString(\"android:label\");\n      if (label.length() == 0) {\n        app.setString(\"android:label\", className);\n      }      \n      \n      // Services need the label also in the service section\n      if (appComp == AndroidBuild.WALLPAPER || appComp == AndroidBuild.WATCHFACE) {\n        XML serv = app.getChild(\"service\");\n        label = serv.getString(\"android:label\");\n        if (label.length() == 0) {\n          serv.setString(\"android:label\", className);\n        }       \n      }\n      \n      // Make sure that the required permissions for watch faces, AR and VR apps are\n      // included. \n      if (appComp == AndroidBuild.WATCHFACE || appComp == AndroidBuild.VR|| appComp == AndroidBuild.AR) {\n        fixPermissions(mf);\n      }\n\n      PrintWriter writer = PApplet.createWriter(file);\n      writer.print(mf.format(4));\n      writer.flush();\n      writer.close();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n\n\n  protected void load(boolean forceNew) { \n    File manifestFile = getManifestFile();\n    if (manifestFile.exists()) {\n      try {\n        xml = new XML(manifestFile);\n\n        boolean saveOld = false;\n\n        XML app = xml.getChild(\"application\");\n        String icon = app.getString(\"android:icon\");\n        if (icon.equals(\"@drawable/icon\")) {\n          // Manifest file generated with older version of the mode, replace icon and save\n          app.setString(\"android:icon\", \"@mipmap/ic_launcher\");\n          saveOld = true;\n        }\n\n        XML activity = app.getChild(\"activity\");\n        XML service = app.getChild(\"service\");\n        if (activity != null && activity.getString(\"android:name\").equals(\".MainActivity\")) {\n          addExportedAttrib(activity);\n          saveOld = true;\n        }\n        if (service != null && service.getString(\"android:name\").equals(\".MainService\")) {\n          addExportedAttrib(service);\n          saveOld = true;\n        }\n\n        XML usesSDK = xml.getChild(\"uses-sdk\");\n        if (usesSDK != null) {\n          // Manifest file generated with older version of the mode, uses-sdk is no longer needed in manifest\n          xml.removeChild(usesSDK);\n          saveOld = true;\n        }\n\n        if (saveOld && !forceNew) save();\n\n      } catch (Exception e) {\n        e.printStackTrace();\n        System.err.println(\"Problem reading AndroidManifest.xml, creating a new version\");\n\n        // remove the old manifest file, rename it with date stamp\n        long lastModified = manifestFile.lastModified();\n        String stamp = AndroidMode.getDateStamp(lastModified);\n        File dest = new File(sketch.getFolder(), MANIFEST_XML + \".\" + stamp);\n        boolean moved = manifestFile.renameTo(dest);\n        if (!moved) {\n          System.err.println(\"Could not move/rename \" + manifestFile.getAbsolutePath());\n          System.err.println(\"You'll have to move or remove it before continuing.\");\n          return;\n        }\n      }\n    }\n    \n    String[] permissionNames = null;\n    String pkgName = null;\n    String versionCode = null;\n    String versionName = null;\n    if (xml != null && forceNew) {\n      permissionNames = getPermissions();\n      pkgName = getPackageName();\n      versionCode = getVersionCode();\n      versionName = getVersionName();\n      xml = null;\n    }\n\n    if (xml == null) {\n      writeBlankManifest(manifestFile, appComp);\n      try {\n        xml = new XML(manifestFile);\n        if (permissionNames != null) {\n          setPermissions(permissionNames);\n        }\n        if (pkgName != null) {\n          xml.setString(\"package\", pkgName);\n        }\n        if (versionCode != null) {\n          xml.setString(\"android:versionCode\", versionCode);\n        }\n        if (versionName != null) {\n          xml.setString(\"android:versionName\", versionName);\n        }       \n      } catch (FileNotFoundException e) {\n        System.err.println(\"Could not read \" + manifestFile.getAbsolutePath());\n        e.printStackTrace();\n      } catch (IOException e) {\n        e.printStackTrace();\n      } catch (ParserConfigurationException e) {\n        e.printStackTrace();\n      } catch (SAXException e) {\n        e.printStackTrace();\n      }\n    }\n    if (xml == null) {\n      Messages.showWarning(AndroidMode.getTextString(\"manifest.warn.cannot_handle_file_title\", MANIFEST_XML), \n                           AndroidMode.getTextString(\"manifest.warn.cannot_handle_file_body\", MANIFEST_XML));\n    }\n  }\n\n  protected void addExportedAttrib(XML child) {\n    if (!child.hasAttribute(\"android:exported\")) {\n      // Manifest file generated with older version of the mode, missing android:exported attributed\n      child.setString(\"android:exported\", \"true\");\n    }\n  }\n\n  protected void save() {\n    save(getManifestFile());\n  }\n\n\n  /**\n   * Save to the sketch folder, so that it can be copied in later.\n   */\n  protected void save(File file) {\n    PrintWriter writer = PApplet.createWriter(file);\n//    xml.write(writer);\n    writer.print(xml.format(4));\n    writer.flush();\n    writer.close();\n  }\n\n\n  private File getManifestFile() {\n    return new File(sketch.getFolder(), MANIFEST_XML);\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/processing/mode/android/Manifest.java b/src/processing/mode/android/Manifest.java
--- a/src/processing/mode/android/Manifest.java	(revision e81b5b41a9b360f8db31e3e9f672c68aae095546)
+++ b/src/processing/mode/android/Manifest.java	(date 1695977415792)
@@ -146,7 +146,7 @@
     boolean hasVibrate = false;
     boolean hasReadExtStorage = false;
     boolean hasCameraAccess = false;
-    
+
     // Remove all the old permissions...
     for (XML kid : xml.getChildren("uses-permission")) {
       String name = kid.getString("android:name");
@@ -168,7 +168,7 @@
         hasCameraAccess = true;
         continue;
       }
-      
+
       // Don't remove non-standard permissions, such as
       // com.google.android.wearable.permission.RECEIVE_COMPLICATION_DATA
       // because these are set manually by the user.
@@ -184,7 +184,7 @@
       if (appComp == AndroidBuild.VR && name.equals("VIBRATE")) continue;
       if (appComp == AndroidBuild.VR && name.equals("READ_EXTERNAL_STORAGE")) continue;
       if (appComp == AndroidBuild.AR && name.equals(PERMISSION_PREFIX + "CAMERA")) continue;
-         
+
       XML newbie = xml.addChild("uses-permission");
       if (-1 < name.indexOf(".")) {
         // Permission string contains path
@@ -255,8 +255,8 @@
     }
     if (appComp == AndroidBuild.VR && !hasReadExtStorage) {
       mf.addChild("uses-permission").
-         setString("android:name", PERMISSION_PREFIX + "READ_EXTERNAL_STORAGE");       
-    }    
+         setString("android:name", PERMISSION_PREFIX + "READ_EXTERNAL_STORAGE");
+    }
   }
   
 
Index: src/processing/mode/android/AndroidBuild.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* -*- mode: java; c-basic-offset: 2; indent-tabs-mode: nil -*- */\r\n\r\n/*\r\n Part of the Processing project - http://processing.org\r\n\r\n Copyright (c) 2012-21 The Processing Foundation\r\n Copyright (c) 2009-12 Ben Fry and Casey Reas\r\n\r\n This program is free software; you can redistribute it and/or modify\r\n it under the terms of the GNU General Public License version 2\r\n as published by the Free Software Foundation.\r\n\r\n This program is distributed in the hope that it will be useful,\r\n but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n GNU General Public License for more details.\r\n\r\n You should have received a copy of the GNU General Public License\r\n along with this program; if not, write to the Free Software Foundation,\r\n Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n */\r\n\r\npackage processing.mode.android;\r\n\r\nimport org.gradle.tooling.*;\r\n\r\nimport processing.app.Base;\r\nimport processing.app.Library;\r\nimport processing.app.Platform;\r\nimport processing.app.Preferences;\r\nimport processing.app.Sketch;\r\nimport processing.app.SketchException;\r\nimport processing.app.Util;\r\nimport processing.core.PApplet;\r\nimport processing.mode.java.JavaBuild;\r\nimport processing.mode.java.preproc.PdePreprocessor;\r\n\r\nimport java.io.*;\r\nimport java.util.HashMap;\r\nimport java.util.Properties;\r\n\r\nimport java.util.*;\r\nimport processing.app.SketchCode;\r\nimport processing.mode.java.preproc.PreprocessorResult;\r\n\r\n\r\n/** \r\n * Class with all the infrastructure needed to build a sketch in the Android \r\n * mode and run it either on the device or in the emulator, using Gradle as the\r\n * build system. It also exports the sketch as a Gradle project file to build \r\n * from the command line or import into Android Studio, and a signed and aligned\r\n * package ready to upload to the Play Store.\r\n */\r\nclass AndroidBuild extends JavaBuild {\r\n  static public final int APP          = 0;\r\n  static public final int WALLPAPER    = 1;\r\n  static public final int WATCHFACE    = 2;\r\n  static public final int VR           = 3;\r\n  static public final int AR           = 4;\r\n  \r\n  // Minimum SDK's API levels required for each component:\r\n  static public String MIN_SDK_APP;\r\n  static public String MIN_SDK_WALLPAPER;\r\n  static public String MIN_SDK_VR;\r\n  static public String MIN_SDK_AR;\r\n  static public String MIN_SDK_WATCHFACE;\r\n  \r\n  // Versions of all required dependencies\r\n  static public String TARGET_SDK;\r\n  static public String TARGET_WEAR_SDK_ARM;\r\n  static public String TARGET_WEAR_SDK;  \r\n  static public String GRADLE_PLUGIN_VER;\r\n  static public String APPCOMPAT_VER;\r\n  static public String V4LEGACY_VER;\r\n  static public String PLAY_SERVICES_VER;\r\n  static public String WEAR_VER;\r\n  static public String GVR_VER;\r\n  static public String GAR_VER;\r\n  \r\n  // Main activity or service \r\n  static private final String APP_ACTIVITY_TEMPLATE = \"AppActivity.java.tmpl\";\r\n  static private final String WALLPAPER_SERVICE_TEMPLATE = \"WallpaperService.java.tmpl\";\r\n  static private final String WATCHFACE_SERVICE_TEMPLATE = \"WatchFaceService.java.tmpl\";\r\n  static private final String VR_ACTIVITY_TEMPLATE = \"VRActivity.java.tmpl\";\r\n  static private final String AR_ACTIVITY_TEMPLATE = \"ARActivity.java.tmpl\";\r\n  \r\n  // Additional resources\r\n  static private final String LAYOUT_ACTIVITY_TEMPLATE = \"LayoutActivity.xml.tmpl\";\r\n  static private final String STYLES_FRAGMENT_TEMPLATE = \"StylesFragment.xml.tmpl\";\r\n  static private final String STYLES_VR_TEMPLATE = \"StylesVR.xml.tmpl\";\r\n  static private final String STYLES_AR_TEMPLATE = \"StylesAR.xml.tmpl\";\r\n  static private final String XML_WALLPAPER_TEMPLATE = \"XMLWallpaper.xml.tmpl\";\r\n  static private final String STRINGS_WALLPAPER_TEMPLATE = \"StringsWallpaper.xml.tmpl\";\r\n  static private final String XML_WATCHFACE_TEMPLATE = \"XMLWatchFace.xml.tmpl\";\r\n  \r\n  // Gradle build files\r\n  static private final String GRADLE_SETTINGS_TEMPLATE = \"Settings.gradle.tmpl\";\r\n  static private final String GRADLE_PROPERTIES_TEMPLATE = \"Properties.gradle.tmpl\";\r\n  static private final String EXPORTED_GRADLE_PROPERTIES_TEMPLATE = \"ExpProperties.gradle.tmpl\";\r\n  static private final String LOCAL_PROPERTIES_TEMPLATE = \"Properties.local.tmpl\";\r\n  static private final String TOP_GRADLE_BUILD_TEMPLATE = \"TopBuild.gradle.tmpl\";\r\n  static private final String APP_GRADLE_BUILD_ECJ_TEMPLATE = \"AppBuildECJ.gradle.tmpl\";\r\n  static private final String APP_GRADLE_BUILD_TEMPLATE = \"AppBuild.gradle.tmpl\";\r\n  static private final String VR_GRADLE_BUILD_ECJ_TEMPLATE = \"VRBuildECJ.gradle.tmpl\";\r\n  static private final String VR_GRADLE_BUILD_TEMPLATE = \"VRBuild.gradle.tmpl\";\r\n  static private final String AR_GRADLE_BUILD_ECJ_TEMPLATE = \"ARBuildECJ.gradle.tmpl\";\r\n  static private final String AR_GRADLE_BUILD_TEMPLATE = \"ARBuild.gradle.tmpl\";\r\n  static private final String WEAR_GRADLE_BUILD_ECJ_TEMPLATE = \"WearBuildECJ.gradle.tmpl\";\r\n  static private final String WEAR_GRADLE_BUILD_TEMPLATE = \"WearBuild.gradle.tmpl\";\r\n  \r\n  // Launcher and watch face icon files\r\n  static final String[] SKETCH_LAUNCHER_ICONS = {\"launcher_36.png\", \"launcher_48.png\", \r\n                                                 \"launcher_72.png\", \"launcher_96.png\", \r\n                                                 \"launcher_144.png\", \"launcher_192.png\"};\r\n  static final String[] SKETCH_OLD_LAUNCHER_ICONS = {\"icon-36.png\", \"icon-48.png\", \r\n                                                     \"icon-72.png\", \"icon-96.png\", \r\n                                                     \"icon-144.png\", \"icon-192.png\"}; \r\n  static final String[] BUILD_LAUNCHER_ICONS = {\"mipmap-ldpi/ic_launcher.png\", \"mipmap-mdpi/ic_launcher.png\", \r\n                                                \"mipmap-hdpi/ic_launcher.png\", \"mipmap-xhdpi/ic_launcher.png\", \r\n                                                \"mipmap-xxhdpi/ic_launcher.png\", \"mipmap-xxxhdpi/ic_launcher.png\"};\r\n  static final String[] SKETCH_WATCHFACE_ICONS = {\"preview_circular.png\", \r\n                                                  \"preview_rectangular.png\"};\r\n  static final String[] BUILD_WATCHFACE_ICONS = {\"drawable-nodpi/preview_circular.png\", \r\n                                                 \"drawable-nodpi/preview_rectangular.png\"};\r\n  \r\n  private int appComponent = APP;\r\n  \r\n  private final AndroidSDK sdk;\r\n  private final File coreZipFile;\r\n\r\n  /** whether this is a \"debug\" or \"release\" build */\r\n  private String target;\r\n  \r\n  /** The manifest for the sketch being built */\r\n  private Manifest manifest;\r\n\r\n  /** temporary folder safely inside a 8.3-friendly folder */\r\n  private File tmpFolder;\r\n\r\n  /** Determines which gradle build template will be used */\r\n  private boolean exportProject = false;\r\n\r\n  /** Renderer used by the sketch */\r\n  private String renderer = \"\";\r\n  \r\n  /** Name of the Gradle module in the project, either app or wear */\r\n  private String module = \"\";\r\n  \r\n  /**\r\n   * Constructor.\r\n   * @param sketch the sketch to be built\r\n   * @param mode reference to the mode\r\n   * @param appComp component (regular handheld app, wallpaper, watch face, VR, AR)\r\n   * @param emu build to run in emulator or on device if false \r\n   */  \r\n  public AndroidBuild(Sketch sketch, AndroidMode mode, int comp) {\r\n    super(sketch);\r\n    appComponent = comp;\r\n    sdk = mode.getSDK();\r\n    coreZipFile = mode.getCoreZipLocation();\r\n    module = appComponent == WATCHFACE ? \"wear\" : \"app\";\r\n  }\r\n\r\n  \r\n  public String getPackageName() {\r\n    return manifest.getPackageName();\r\n  }\r\n  \r\n\r\n  public int getAppComponent() {\r\n    return appComponent;\r\n  }\r\n  \r\n  \r\n  public boolean isWear() {\r\n    return appComponent == WATCHFACE;\r\n  }  \r\n\r\n\r\n  public void cleanup() {\r\n    tmpFolder.deleteOnExit();\r\n  }  \r\n\r\n  \r\n  public boolean usesOpenGL() {\r\n    return renderer != null && (renderer.equals(\"P2D\") || renderer.equals(\"P3D\")); \r\n  }\r\n  \r\n  \r\n  public String getPathForAPK() {\r\n    String suffix = target.equals(\"release\") ? \"release\" : \"debug\";\r\n    String apkName = getPathToAPK() + sketch.getName().toLowerCase() + \"_\" + suffix + \".apk\";\r\n    final File apkFile = new File(tmpFolder, apkName);\r\n    if (!apkFile.exists()) {\r\n      return null;\r\n    }\r\n    return apkFile.getAbsolutePath();\r\n  }\r\n\r\n  /**\r\n   * Build into temporary folders  for building bundles (needed for the Windows 8.3 bugs in the Android SDK)\r\n   * @param target \"debug\" or \"release\"\r\n   * @throws SketchException\r\n   * @throws IOException\r\n   */\r\n  public File buildBundle(String target, String password) throws IOException, SketchException {\r\n    this.target = target;\r\n    File folder = createProject(true, password);\r\n    if (folder == null) return null;\r\n    if (!gradleBuildBundle()) return null;\r\n    return folder;\r\n  }\r\n\r\n\r\n  /**\r\n   * Build into temporary folders (needed for the Windows 8.3 bugs in the Android SDK).\r\n   * @param target \"debug\" or \"release\"\r\n   * @throws SketchException\r\n   * @throws IOException\r\n   */\r\n  public File build(String target, String password) throws IOException, SketchException {\r\n    this.target = target;        \r\n    File folder = createProject(true, password);\r\n    if (folder == null) return null;\r\n    if (!gradleBuildPackage()) return null;\r\n    return folder;      \r\n  }\r\n\r\n\r\n  /**\r\n   * Create an Gradle Android project folder, and run the preprocessor on the\r\n   * sketch. Creates the top and app modules in the case of regular, VR, AR and\r\n   * wallpapers, and top, mobile and wear modules in the case of watch faces.\r\n   */\r\n  protected File createProject(boolean external, String password) \r\n      throws IOException, SketchException {\r\n    tmpFolder = createTempBuildFolder(sketch);\r\n    System.out.println(AndroidMode.getTextString(\"android_build.error.build_folder\", tmpFolder.getAbsolutePath()));\r\n\r\n    // Create the 'src' folder with the preprocessed code.\r\n    srcFolder = new File(tmpFolder, module + \"/src/main/java\");\r\n    binFolder = srcFolder; // Needed in the the parent JavaBuild class\r\n    if (processing.app.Base.DEBUG) {\r\n      Platform.openFolder(tmpFolder);\r\n    }\r\n\r\n    manifest = new Manifest(sketch, appComponent, mode.getFolder(), false);    \r\n    \r\n    // build the preproc and get to work\r\n    String pckgName = getPackageName();\r\n    PdePreprocessor preprocessor = PdePreprocessor.builderFor(sketch.getName()).setDestinationPackage(pckgName).build();        \r\n    PreprocessorResult result = preprocess(srcFolder, pckgName, preprocessor, false);    \r\n    if (result != null) {\r\n      sketchClassName = result.getClassName();\r\n      if (sketchClassName != null) {\r\n        renderer = result.getSketchRenderer();\r\n        if (renderer == null) {\r\n          renderer = \"JAVA2D\";\r\n        }\r\n        writeMainClass(srcFolder, external);\r\n        createTopModule(\"':\" + module + \"'\", password);\r\n        createAppModule(module);  \r\n      }\r\n    }\r\n    \r\n    return tmpFolder;\r\n  }\r\n\r\n  \r\n  protected boolean gradleBuildBundle() throws SketchException {\r\n    ProjectConnection connection = GradleConnector.newConnector()\r\n            .forProjectDirectory(tmpFolder)\r\n            .connect();\r\n\r\n    boolean success = false;\r\n    BuildLauncher build = connection.newBuild();\r\n    build.setStandardOutput(System.out);\r\n    build.setStandardError(System.err);\r\n\r\n    try {\r\n      if (target.equals(\"debug\")) build.forTasks(\"bundleDebug\");\r\n      else build.forTasks(\"bundleRelease\");\r\n      build.run();\r\n      renameAAB();\r\n      success = true;\r\n    } catch (org.gradle.tooling.UnsupportedVersionException e) {\r\n      e.printStackTrace();\r\n      success = false;\r\n    } catch (org.gradle.tooling.BuildException e) {\r\n      e.printStackTrace();\r\n      success = false;\r\n    } catch (org.gradle.tooling.BuildCancelledException e) {\r\n      e.printStackTrace();\r\n      success = false;\r\n    } catch (org.gradle.tooling.GradleConnectionException e) {\r\n      e.printStackTrace();\r\n      success = false;\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n      success = false;\r\n    } finally {\r\n      connection.close();\r\n    }\r\n\r\n    try {\r\n      removeKeyPassword();\r\n    } catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n\r\n    return success;\r\n  }\r\n    \r\n  \r\n  protected boolean gradleBuildPackage() throws SketchException {\r\n    ProjectConnection connection = GradleConnector.newConnector()\r\n            .forProjectDirectory(tmpFolder)\r\n            .connect();\r\n\r\n    boolean success = false;\r\n    BuildLauncher build = connection.newBuild();\r\n    build.setStandardOutput(System.out);\r\n    build.setStandardError(System.err);\r\n\r\n    try {      \r\n      if (target.equals(\"debug\")) build.forTasks(\"assembleDebug\");\r\n      else build.forTasks(\"assembleRelease\");\r\n      build.run();\r\n      renameAPK();\r\n      success = true;\r\n    } catch (org.gradle.tooling.UnsupportedVersionException e) {\r\n      e.printStackTrace();\r\n      success = false;   \r\n    } catch (org.gradle.tooling.BuildException e) {      \r\n      e.printStackTrace();\r\n      success = false;\r\n    } catch (org.gradle.tooling.BuildCancelledException e) {\r\n      e.printStackTrace();\r\n      success = false;      \r\n    } catch (org.gradle.tooling.GradleConnectionException e) {\r\n      e.printStackTrace();\r\n      success = false;        \r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n      success = false;      \r\n    } finally {\r\n      connection.close();\r\n    }\r\n    \r\n    try {\r\n      removeKeyPassword();\r\n    } catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n\r\n    return success;\r\n  }\r\n  \r\n  \r\n  // ---------------------------------------------------------------------------\r\n  // Gradle modules  \r\n  \r\n  \r\n  private void createTopModule(String projectModules, String keyPassword) \r\n      throws IOException {    \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    \r\n    File buildTemplate = mode.getContentFile(\"templates/\" + TOP_GRADLE_BUILD_TEMPLATE);\r\n    File buildlFile = new File(tmpFolder, \"build.gradle\");\r\n    replaceMap.put(\"@@gradle_plugin_version@@\", GRADLE_PLUGIN_VER);\r\n    AndroidUtil.createFileFromTemplate(buildTemplate, buildlFile, replaceMap);\r\n\r\n//    File gradlePropsTemplate = mode.getContentFile(\"templates/\" + GRADLE_PROPERTIES_TEMPLATE);\r\n//    File gradlePropsFile = new File(tmpFolder, \"gradle.properties\");\r\n//    Util.copyFile(gradlePropsTemplate, gradlePropsFile);\r\n    File gradlePropsTemplate;\r\n    if (exportProject) {\r\n      gradlePropsTemplate = mode.getContentFile(\"templates/\" + EXPORTED_GRADLE_PROPERTIES_TEMPLATE);\r\n    } else {\r\n      gradlePropsTemplate = mode.getContentFile(\"templates/\" + GRADLE_PROPERTIES_TEMPLATE);\r\n    }\r\n    File gradlePropsFile = new File(tmpFolder, \"gradle.properties\");\r\n    String javaHome = Platform.getJavaHome().getAbsolutePath();\r\n    replaceMap.clear();\r\n    replaceMap.put(\"@@java_home@@\", javaHome);\r\n    if (!keyPassword.equals(\"\") && AndroidKeyStore.getKeyStore() != null) {\r\n      replaceMap.put(\"@@keystore_file@@\", AndroidKeyStore.getKeyStore().getAbsolutePath().replace('\\\\', '/'));\r\n      replaceMap.put(\"@@key_alias@@\", AndroidKeyStore.ALIAS_STRING);  \r\n      replaceMap.put(\"@@key_password@@\", keyPassword);\r\n    }    \r\n    AndroidUtil.createFileFromTemplate(gradlePropsTemplate, gradlePropsFile, replaceMap);\r\n    \r\n    File settingsTemplate = mode.getContentFile(\"templates/\" + GRADLE_SETTINGS_TEMPLATE);\r\n    File settingsFile = new File(tmpFolder, \"settings.gradle\");\r\n    replaceMap.clear();\r\n    if (getAppComponent() == VR) {\r\n      // The local google-vr has to be added to the settings to fix Issue #718\r\n      replaceMap.put(\"@@project_modules@@\", projectModules + \", ':app:libs:google-vr'\");      \r\n    } else {\r\n      replaceMap.put(\"@@project_modules@@\", projectModules);\r\n    }\r\n    \r\n    AndroidUtil.createFileFromTemplate(settingsTemplate, settingsFile, replaceMap);\r\n    \r\n    File localPropsTemplate = mode.getContentFile(\"templates/\" + LOCAL_PROPERTIES_TEMPLATE);\r\n    File localPropsFile = new File(tmpFolder, \"local.properties\");\r\n    replaceMap.clear();\r\n    final String sdkPath = sdk.getFolder().getAbsolutePath();\r\n    if (Platform.isWindows()) {\r\n      // Windows needs backslashes escaped, or it will also accept forward\r\n      // slashes in the build file. We're using the forward slashes since this\r\n      // path gets concatenated with a lot of others that use forwards anyway.\r\n      replaceMap.put(\"@@sdk_path@@\", sdkPath.replace('\\\\', '/'));\r\n    } else {\r\n      replaceMap.put(\"@@sdk_path@@\", sdkPath);\r\n    }\r\n    AndroidUtil.createFileFromTemplate(localPropsTemplate, localPropsFile, replaceMap);\r\n  }\r\n  \r\n  \r\n  private void createAppModule(String moduleName)\r\n      throws SketchException, IOException {\r\n    File moduleFolder = AndroidUtil.createPath(tmpFolder, moduleName);\r\n    \r\n    String minSdk;\r\n    String tmplFile;\r\n    if (appComponent == AR) {\r\n      minSdk = MIN_SDK_AR;\r\n      tmplFile = exportProject ? AR_GRADLE_BUILD_TEMPLATE : AR_GRADLE_BUILD_ECJ_TEMPLATE;\r\n    } else if (appComponent == VR) {\r\n      minSdk = MIN_SDK_VR;\r\n      tmplFile = exportProject ? VR_GRADLE_BUILD_TEMPLATE : VR_GRADLE_BUILD_ECJ_TEMPLATE;\r\n    } else if (appComponent == WATCHFACE) {\r\n      minSdk = MIN_SDK_WATCHFACE;\r\n      tmplFile = exportProject ? WEAR_GRADLE_BUILD_TEMPLATE : WEAR_GRADLE_BUILD_ECJ_TEMPLATE;      \r\n    } else {\r\n      minSdk = MIN_SDK_APP;\r\n      tmplFile = exportProject ? APP_GRADLE_BUILD_TEMPLATE : APP_GRADLE_BUILD_ECJ_TEMPLATE;\r\n    }\r\n    \r\n    String modePath = new File(mode.getFolder(), \"mode\").getPath().replace('\\\\', '/');\r\n    String toolPath = Base.getToolsFolder().getPath().replace('\\\\', '/');\r\n    String platformPath = sdk.getTargetPlatform(TARGET_SDK).getPath().replace('\\\\', '/');\r\n    \r\n    File appBuildTemplate = mode.getContentFile(\"templates/\" + tmplFile);    \r\n    File appBuildFile = new File(moduleFolder, \"build.gradle\");    \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@mode_folder@@\", modePath);\r\n    replaceMap.put(\"@@tools_folder@@\", toolPath);\r\n    replaceMap.put(\"@@target_platform@@\", platformPath);\r\n    replaceMap.put(\"@@package_name@@\", getPackageName());    \r\n    replaceMap.put(\"@@min_sdk@@\", minSdk);  \r\n    replaceMap.put(\"@@target_sdk@@\", TARGET_SDK);\r\n    replaceMap.put(\"@@appcompat_version@@\", APPCOMPAT_VER);    \r\n    replaceMap.put(\"@@v4legacy_version@@\", V4LEGACY_VER);\r\n    replaceMap.put(\"@@play_services_version@@\", PLAY_SERVICES_VER);\r\n    replaceMap.put(\"@@wear_version@@\", WEAR_VER);        \r\n    replaceMap.put(\"@@gvr_version@@\", GVR_VER);\r\n    replaceMap.put(\"@@gar_version@@\", GAR_VER);\r\n    replaceMap.put(\"@@version_code@@\", manifest.getVersionCode());\r\n    replaceMap.put(\"@@version_name@@\", manifest.getVersionName());\r\n    AndroidUtil.createFileFromTemplate(appBuildTemplate, appBuildFile, replaceMap);\r\n\r\n    AndroidUtil.writeFile(new File(moduleFolder, \"proguard-rules.pro\"),\r\n        new String[]{\"# Add project specific ProGuard rules here.\"});\r\n\r\n    File libsFolder = AndroidUtil.createPath(moduleFolder, \"libs\");\r\n    File mainFolder = new File(moduleFolder, \"src/main\");\r\n    File resFolder = AndroidUtil.createPath(mainFolder, \"res\");\r\n    File assetsFolder = AndroidUtil.createPath(mainFolder, \"assets\");\r\n\r\n    writeRes(resFolder);\r\n\r\n    File tempManifest = new File(mainFolder, \"AndroidManifest.xml\");\r\n    manifest.writeCopy(tempManifest, sketchClassName);\r\n\r\n    Util.copyFile(coreZipFile, new File(libsFolder, \"processing-core.jar\"));\r\n\r\n    // Copy any imported libraries (their libs and assets),\r\n    // and anything in the code folder contents to the project.\r\n    copyImportedLibs(libsFolder, mainFolder, assetsFolder);\r\n    copyCodeFolder(libsFolder);\r\n\r\n    if (getAppComponent() == VR) {\r\n      // Need to call this to fix Issue #718\r\n      copyGVRLibs(libsFolder);\r\n    }\r\n\r\n    // Copy the data folder (if one exists) to the project's 'assets' folder\r\n    final File sketchDataFolder = sketch.getDataFolder();\r\n    if (sketchDataFolder.exists()) {\r\n      Util.copyDir(sketchDataFolder, assetsFolder);\r\n    }\r\n\r\n    // Do the same for the 'res' folder. The user can copy an entire res folder\r\n    // into the sketch's folder, and it will be used in the project!\r\n    final File sketchResFolder = new File(sketch.getFolder(), \"res\");\r\n    if (sketchResFolder.exists()) {\r\n      Util.copyDir(sketchResFolder, resFolder);\r\n    }\r\n  }\r\n  \r\n  \r\n  // ---------------------------------------------------------------------------\r\n  // Templates\r\n  \r\n\r\n  private void writeMainClass(final File srcDirectory, final boolean external) {\r\n    int comp = getAppComponent();\r\n    String[] permissions = manifest.getPermissions();\r\n    if (comp == APP) {\r\n      writeFragmentActivity(srcDirectory, permissions, external);\r\n    } else if (comp == WALLPAPER) {\r\n      writeWallpaperService(srcDirectory, permissions, external);\r\n    } else if (comp == WATCHFACE) {\r\n      if (usesOpenGL()) {\r\n        writeWatchFaceGLESService(srcDirectory, permissions, external);  \r\n      } else {\r\n        writeWatchFaceCanvasService(srcDirectory, permissions, external);  \r\n      }      \r\n    } else if (comp == VR) {\r\n      writeVRActivity(srcDirectory, permissions, external);\r\n    } else if (comp == AR) {\r\n      writeARActivity(srcDirectory, permissions, external);\r\n    }\r\n  }\r\n\r\n  \r\n  private void writeFragmentActivity(final File srcDirectory, \r\n      final String[] permissions, final boolean external) {    \r\n    File javaTemplate = mode.getContentFile(\"templates/\" + APP_ACTIVITY_TEMPLATE);    \r\n    File javaFile = new File(new File(srcDirectory, getPackageName().replace(\".\", \"/\")), \"MainActivity.java\");\r\n    \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@package_name@@\", getPackageName());\r\n    replaceMap.put(\"@@sketch_class_name@@\", sketchClassName);\r\n    replaceMap.put(\"@@external@@\", external ? \"sketch.setExternal(true);\" : \"\");\r\n    \r\n    AndroidUtil.createFileFromTemplate(javaTemplate, javaFile, replaceMap);\r\n  }\r\n  \r\n  \r\n  private void writeWallpaperService(final File srcDirectory, \r\n      String[] permissions, final boolean external) {    \r\n    File javaTemplate = mode.getContentFile(\"templates/\" + WALLPAPER_SERVICE_TEMPLATE);\r\n    File javaFile = new File(new File(srcDirectory, getPackageName().replace(\".\", \"/\")), \"MainService.java\");\r\n    \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@package_name@@\", getPackageName());\r\n    replaceMap.put(\"@@sketch_class_name@@\", sketchClassName);\r\n    replaceMap.put(\"@@external@@\", external ? \"sketch.setExternal(true);\" : \"\");    \r\n    \r\n    AndroidUtil.createFileFromTemplate(javaTemplate, javaFile, replaceMap); \r\n  }\r\n  \r\n  \r\n  private void writeWatchFaceGLESService(final File srcDirectory, \r\n      String[] permissions, final boolean external) {\r\n    File javaTemplate = mode.getContentFile(\"templates/\" + WATCHFACE_SERVICE_TEMPLATE);\r\n    File javaFile = new File(new File(srcDirectory, getPackageName().replace(\".\", \"/\")), \"MainService.java\");\r\n    \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@watchface_classs@@\", \"PWatchFaceGLES\");\r\n    replaceMap.put(\"@@package_name@@\", getPackageName());\r\n    replaceMap.put(\"@@sketch_class_name@@\", sketchClassName);\r\n    replaceMap.put(\"@@external@@\", external ? \"sketch.setExternal(true);\" : \"\");    \r\n    \r\n    AndroidUtil.createFileFromTemplate(javaTemplate, javaFile, replaceMap);     \r\n  }\r\n\r\n  \r\n  private void writeWatchFaceCanvasService(final File srcDirectory, \r\n      String[] permissions, final boolean external) {\r\n    File javaTemplate = mode.getContentFile(\"templates/\" + WATCHFACE_SERVICE_TEMPLATE);\r\n    File javaFile = new File(new File(srcDirectory, getPackageName().replace(\".\", \"/\")), \"MainService.java\");\r\n    \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@watchface_classs@@\", \"PWatchFaceCanvas\");\r\n    replaceMap.put(\"@@package_name@@\", getPackageName());\r\n    replaceMap.put(\"@@sketch_class_name@@\", sketchClassName);\r\n    replaceMap.put(\"@@external@@\", external ? \"sketch.setExternal(true);\" : \"\"); \r\n    \r\n    AndroidUtil.createFileFromTemplate(javaTemplate, javaFile, replaceMap); \r\n  }  \r\n  \r\n  \r\n  private void writeVRActivity(final File srcDirectory, String[] permissions, \r\n      final boolean external) {\r\n    File javaTemplate = mode.getContentFile(\"templates/\" + VR_ACTIVITY_TEMPLATE);    \r\n    File javaFile = new File(new File(srcDirectory, getPackageName().replace(\".\", \"/\")), \"MainActivity.java\");\r\n    \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@package_name@@\", getPackageName());\r\n    replaceMap.put(\"@@sketch_class_name@@\", sketchClassName);\r\n    replaceMap.put(\"@@external@@\", external ? \"sketch.setExternal(true);\" : \"\");\r\n    \r\n    AndroidUtil.createFileFromTemplate(javaTemplate, javaFile, replaceMap); \r\n  }\r\n\r\n  private void writeARActivity(final File srcDirectory, String[] permissions,\r\n      final boolean external) {\r\n    File javaTemplate = mode.getContentFile(\"templates/\" + AR_ACTIVITY_TEMPLATE);\r\n    File javaFile = new File(new File(srcDirectory, getPackageName().replace(\".\", \"/\")), \"MainActivity.java\");\r\n\r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@package_name@@\", getPackageName());\r\n    replaceMap.put(\"@@sketch_class_name@@\", sketchClassName);\r\n    replaceMap.put(\"@@external@@\", external ? \"sketch.setExternal(true);\" : \"\");\r\n\r\n    AndroidUtil.createFileFromTemplate(javaTemplate, javaFile, replaceMap);\r\n  }\r\n\r\n  \r\n  private void writeResLayoutMainActivity(final File layoutFolder) {\r\n    File xmlTemplate = mode.getContentFile(\"templates/\" + LAYOUT_ACTIVITY_TEMPLATE);\r\n    File xmlFile = new File(layoutFolder, \"main.xml\");\r\n        \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@sketch_class_name@@\",sketchClassName);\r\n        \r\n    AndroidUtil.createFileFromTemplate(xmlTemplate, xmlFile, replaceMap); \r\n  }\r\n  \r\n  \r\n  private void writeResStylesFragment(final File valuesFolder) {\r\n    File xmlTemplate = mode.getContentFile(\"templates/\" + STYLES_FRAGMENT_TEMPLATE);\r\n    File xmlFile = new File(valuesFolder, \"styles.xml\");\r\n    AndroidUtil.createFileFromTemplate(xmlTemplate, xmlFile); \r\n  }\r\n  \r\n  \r\n  private void writeResStylesVR(final File valuesFolder) {\r\n    File xmlTemplate = mode.getContentFile(\"templates/\" + STYLES_VR_TEMPLATE);\r\n    File xmlFile = new File(valuesFolder, \"styles.xml\");\r\n    AndroidUtil.createFileFromTemplate(xmlTemplate, xmlFile);\r\n  }\r\n\r\n\r\n  private void writeResStylesAR(final File valuesFolder) {\r\n    File xmlTemplate = mode.getContentFile(\"templates/\" + STYLES_AR_TEMPLATE);\r\n    File xmlFile = new File(valuesFolder, \"styles.xml\");\r\n    AndroidUtil.createFileFromTemplate(xmlTemplate, xmlFile);\r\n  }\r\n  \r\n\r\n  private void writeResXMLWallpaper(final File xmlFolder) {\r\n    File xmlTemplate = mode.getContentFile(\"templates/\" + XML_WALLPAPER_TEMPLATE);\r\n    File xmlFile = new File(xmlFolder, \"wallpaper.xml\");\r\n    AndroidUtil.createFileFromTemplate(xmlTemplate, xmlFile);\r\n  }\r\n  \r\n  \r\n  private void writeResStringsWallpaper(final File valuesFolder) {\r\n    File xmlTemplate = mode.getContentFile(\"templates/\" + STRINGS_WALLPAPER_TEMPLATE);\r\n    File xmlFile = new File(valuesFolder, \"strings.xml\");\r\n    \r\n    HashMap<String, String> replaceMap = new HashMap<String, String>();\r\n    replaceMap.put(\"@@sketch_class_name@@\",sketchClassName);\r\n        \r\n    AndroidUtil.createFileFromTemplate(xmlTemplate, xmlFile, replaceMap);  \r\n  }\r\n  \r\n  \r\n  private void writeResXMLWatchFace(final File xmlFolder) {\r\n    File xmlTemplate = mode.getContentFile(\"templates/\" + XML_WATCHFACE_TEMPLATE);\r\n    File xmlFile = new File(xmlFolder, \"watch_face.xml\");\r\n    AndroidUtil.createFileFromTemplate(xmlTemplate, xmlFile);\r\n  } \r\n  \r\n  \r\n  private void writeRes(File resFolder) throws SketchException {\r\n    File layoutFolder = AndroidUtil.createPath(resFolder, \"layout\");    \r\n    writeResLayoutMainActivity(layoutFolder);\r\n\r\n    int comp = getAppComponent();\r\n    if (comp == APP) {\r\n      File valuesFolder = AndroidUtil.createPath(resFolder, \"values\");      \r\n      writeResStylesFragment(valuesFolder);\r\n    } else if (comp == WALLPAPER) {\r\n      File xmlFolder = AndroidUtil.createPath(resFolder, \"xml\");      \r\n      writeResXMLWallpaper(xmlFolder);\r\n      File valuesFolder = AndroidUtil.createPath(resFolder, \"values\");      \r\n      writeResStringsWallpaper(valuesFolder);      \r\n    } else if (comp == WATCHFACE) { \r\n      File xmlFolder = AndroidUtil.createPath(resFolder, \"xml\");      \r\n      writeResXMLWatchFace(xmlFolder); \r\n    } else if (comp == VR) {\r\n      File valuesFolder = AndroidUtil.createPath(resFolder, \"values\");      \r\n      writeResStylesVR(valuesFolder);  \r\n    } else if (comp == AR) {\r\n      File valuesFolder = AndroidUtil.createPath(resFolder, \"values\");\r\n      writeResStylesAR(valuesFolder);\r\n    }\r\n    \r\n    File sketchFolder = sketch.getFolder();\r\n    writeLauncherIconFiles(sketchFolder, resFolder);\r\n    if (comp == WATCHFACE) {\r\n      // Need the preview icons for watch faces.\r\n      writeWatchFaceIconFiles(sketchFolder, resFolder);\r\n    }\r\n  }\r\n\r\n  \r\n  // ---------------------------------------------------------------------------\r\n  // Icons  \r\n  \r\n  \r\n  private void writeLauncherIconFiles(File sketchFolder, File resFolder) {\r\n    writeIconFiles(sketchFolder, resFolder, SKETCH_LAUNCHER_ICONS, SKETCH_OLD_LAUNCHER_ICONS, BUILD_LAUNCHER_ICONS);\r\n  }\r\n  \r\n  \r\n  private void writeWatchFaceIconFiles(File sketchFolder, File resFolder) {\r\n    writeIconFiles(sketchFolder, resFolder, SKETCH_WATCHFACE_ICONS, null, BUILD_WATCHFACE_ICONS);\r\n  }\r\n  \r\n  \r\n  private void writeIconFiles(File sketchFolder, File resFolder, \r\n                              String[] sketchIconNames, String[] oldIconNames, String[] buildIconNames) {\r\n    File[] localIcons = AndroidUtil.getFileList(sketchFolder, sketchIconNames, oldIconNames);\r\n    File[] buildIcons = AndroidUtil.getFileList(resFolder, buildIconNames);\r\n    if (AndroidUtil.noFileExists(localIcons)) {\r\n      // If no icons are in the sketch folder, then copy all the defaults      \r\n      File[] defaultIcons = AndroidUtil.getFileList(mode, \"icons/\", sketchIconNames);      \r\n      try {\r\n        for (int i = 0; i < localIcons.length; i++) {\r\n          copyIcon(defaultIcons[i], buildIcons[i]);  \r\n        }\r\n      } catch (IOException e) {\r\n        e.printStackTrace();\r\n      }\r\n    } else {\r\n      // If at least one of the icons already exists, then use that across the board\r\n      try {\r\n        for (int i = 0; i < localIcons.length; i++) {\r\n          if (localIcons[i].exists()) copyIcon(localIcons[i], buildIcons[i]);\r\n        }\r\n      } catch (IOException e) {\r\n        System.err.println(AndroidMode.getTextString(\"android_build.error.cannot_copy_icons\"));\r\n        e.printStackTrace();\r\n      }\r\n    }\r\n  }\r\n  \r\n  \r\n  private void copyIcon(File srcFile, File destFile) throws IOException {\r\n    File parent = destFile.getParentFile();\r\n    if (parent.exists() || parent.mkdirs()) {\r\n      Util.copyFile(srcFile, destFile);\r\n    } else {\r\n      System.err.println(AndroidMode.getTextString(\"android_build.error.cannot_create_icon_folder\", destFile.getParentFile()));\r\n    }    \r\n  }  \r\n\r\n  \r\n  // ---------------------------------------------------------------------------\r\n  // Export project\r\n\r\n\r\n  public File exportProject() throws IOException, SketchException {\r\n    target = \"debug\";\r\n    \r\n    exportProject = true;\r\n    File projectFolder = createProject(false, \"\");\r\n    exportProject = false;\r\n    \r\n    File exportFolder = createExportFolder(\"android\");      \r\n    Util.copyDir(projectFolder, exportFolder);\r\n    installGradlew(exportFolder);\r\n    return exportFolder;    \r\n  }\r\n\r\n\r\n  // ---------------------------------------------------------------------------\r\n  // Export bundle\r\n\r\n\r\n  public File exportBundle(String keyStorePassword) throws Exception {\r\n    File projectFolder = buildBundle(\"release\", keyStorePassword);\r\n    if (projectFolder == null) return null;\r\n\r\n    // Final export folder\r\n    File exportFolder = createExportFolder(\"buildBundle\");\r\n    Util.copyDir(new File(projectFolder, getPathToAAB()), exportFolder);\r\n    return exportFolder;\r\n  }\r\n  \r\n  \r\n  // ---------------------------------------------------------------------------\r\n  // Export package\r\n  \r\n  \r\n  public File exportPackage(String keyStorePassword) throws Exception {\r\n    File projectFolder = build(\"release\", keyStorePassword);\r\n    if (projectFolder == null) return null;\r\n\r\n    // Final export folder\r\n    File exportFolder = createExportFolder(\"buildPackage\");\r\n    Util.copyDir(new File(projectFolder, getPathToAPK()), exportFolder);    \r\n    return exportFolder;\r\n  }\r\n  \r\n  \r\n  //---------------------------------------------------------------------------\r\n  // Build utils\r\n  \r\n  \r\n  /**\r\n   * Tell the PDE to not complain about android.* packages and others that are\r\n   * part of the OS library set as if they're missing.\r\n   */\r\n  protected boolean ignorableImport(String pkg) {\r\n    if (pkg.startsWith(\"android.\")) return true;\r\n    if (pkg.startsWith(\"java.\")) return true;\r\n    if (pkg.startsWith(\"javax.\")) return true;\r\n    if (pkg.startsWith(\"org.apache.http.\")) return true;\r\n    if (pkg.startsWith(\"org.json.\")) return true;\r\n    if (pkg.startsWith(\"org.w3c.dom.\")) return true;\r\n    if (pkg.startsWith(\"org.xml.sax.\")) return true;\r\n\r\n    if (pkg.startsWith(\"processing.core.\")) return true;\r\n    if (pkg.startsWith(\"processing.data.\")) return true;\r\n    if (pkg.startsWith(\"processing.event.\")) return true;\r\n    if (pkg.startsWith(\"processing.opengl.\")) return true;\r\n\r\n    return false;\r\n  }  \r\n  \r\n  \r\n  /**\r\n   * For each library, copy .jar and .zip files to the 'libs' folder,\r\n   * and copy anything else to the 'assets' folder.\r\n   */\r\n  private void copyImportedLibs(final File libsFolder, \r\n                                final File mainFolder,\r\n                                final File assetsFolder) throws IOException {\r\n    for (Library library : getImportedLibraries()) {\r\n      // Add each item from the library folder / export list to the output\r\n      for (File exportFile : library.getApplicationExports(\"armeabi\")) {\r\n        copyImportedLib(libsFolder, mainFolder, assetsFolder, exportFile);\r\n      }\r\n      for (File exportFile : library.getApplicationExports(\"armeabi-v7a\")) {\r\n        copyImportedLib(libsFolder, mainFolder, assetsFolder, exportFile);\r\n      }\r\n      for (File exportFile : library.getApplicationExports(\"x86\")) {\r\n        copyImportedLib(libsFolder, mainFolder, assetsFolder, exportFile);\r\n      }\r\n      for (File exportFile : library.getApplicationExports(\"arm64-v8a\")) {\r\n        copyImportedLib(libsFolder, mainFolder, assetsFolder, exportFile);\r\n      }\r\n      for (File exportFile : library.getApplicationExports(\"x86_64\")) {\r\n        copyImportedLib(libsFolder, mainFolder, assetsFolder, exportFile);\r\n      }\r\n    }\r\n  }\r\n\r\n  private void copyImportedLib(final File libsFolder, \r\n                               final File mainFolder,\r\n                               final File assetsFolder,\r\n                               final File exportFile) throws IOException {\r\n    String exportName = exportFile.getName();\r\n        \r\n    // Skip the GVR and ARCore jars, because gradle will resolve the dependencies\r\n    if (appComponent == VR && exportName.toLowerCase().startsWith(\"sdk\")) return;\r\n    if (appComponent == AR && exportName.toLowerCase().startsWith(\"core\")) return;\r\n\r\n    if (!exportFile.exists()) {\r\n      System.err.println(AndroidMode.getTextString(\"android_build.error.export_file_does_not_exist\", exportFile.getName()));\r\n    } else if (exportFile.isDirectory()) {\r\n      // Copy native library folders to the correct location\r\n      if (exportName.equals(\"armeabi\")     ||\r\n          exportName.equals(\"armeabi-v7a\") ||\r\n          exportName.equals(\"x86\")         ||\r\n          exportName.equals(\"arm64-v8a\")   ||\r\n          exportName.equals(\"x86_64\")) \r\n      {\r\n        Util.copyDir(exportFile, new File(libsFolder, exportName));\r\n      }\r\n      // Copy jni libraries (.so files) to the correct location\r\n      else if (exportName.equals(\"jniLibs\")) {\r\n        Util.copyDir(exportFile, new File(mainFolder, exportName));\r\n      }\r\n      else {\r\n        // Copy any other directory to the assets folder\r\n        Util.copyDir(exportFile, new File(assetsFolder, exportName));\r\n      }\r\n    } else if (exportName.toLowerCase().endsWith(\".zip\")) {\r\n      // As of r4 of the Android SDK, it looks like .zip files\r\n      // are ignored in the libs folder, so rename to .jar\r\n      System.err.println(AndroidMode.getTextString(\"android_build.error.zip_files_not_allowed\", exportFile.getName()));\r\n      String jarName = exportName.substring(0, exportName.length() - 4) + \".jar\";\r\n      Util.copyFile(exportFile, new File(libsFolder, jarName));\r\n\r\n    } else if (exportName.toLowerCase().endsWith(\".jar\")) {\r\n      Util.copyFile(exportFile, new File(libsFolder, exportName));\r\n\r\n    } else {\r\n      Util.copyFile(exportFile, new File(assetsFolder, exportName));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Copy the dummy Gradle project containing aar files from Google VR,\r\n   * so they can be imported locally from the project\r\n   */  \r\n  private void copyGVRLibs(final File libsFolder) throws IOException {\r\n    File srcFolder = new File(mode.getFolder(), \"libraries/vr/libs/google-vr\");\r\n    File dstFolder = new File(libsFolder, \"google-vr\");\r\n    Util.copyDir(srcFolder, dstFolder);\r\n  }\r\n  \r\n  private void copyCodeFolder(final File libsFolder) throws IOException {\r\n    // Copy files from the 'code' directory into the 'libs' folder\r\n    final File codeFolder = sketch.getCodeFolder();\r\n    if (codeFolder != null && codeFolder.exists()) {\r\n      for (final File item : codeFolder.listFiles()) {\r\n        if (!item.isDirectory()) {\r\n          final String name = item.getName();\r\n          final String lcname = name.toLowerCase();\r\n          if (lcname.endsWith(\".jar\") || lcname.endsWith(\".zip\")) {\r\n            String jarName = name.substring(0, name.length() - 4) + \".jar\";\r\n            Util.copyFile(item, new File(libsFolder, jarName));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private void renameAAB() {\r\n    String suffix = target.equals(\"release\") ? \"release\" : \"debug\";\r\n    String aabName = getPathToAAB() + module + \"-\" + suffix + \".aab\";\r\n    final File aabFile = new File(tmpFolder, aabName);\r\n    if (aabFile.exists()) {\r\n      String suffixNew = target.equals(\"release\") ? \"release\" : \"debug\";\r\n      String aabNameNew = getPathToAAB() +\r\n              sketch.getName().toLowerCase() + \"_\" + suffixNew + \".aab\";\r\n      final File aabFileNew = new File(tmpFolder, aabNameNew);\r\n      aabFile.renameTo(aabFileNew);\r\n    }\r\n  }\r\n\r\n  private String getPathToAAB() {\r\n    return module + \"/build/outputs/bundle/\" + target + \"/\";\r\n  }\r\n\r\n\r\n  private void renameAPK() {\r\n    String suffix = target.equals(\"release\") ? \"release\" : \"debug\";\r\n    String apkName = getPathToAPK() + module + \"-\" + suffix + \".apk\";\r\n    final File apkFile = new File(tmpFolder, apkName);\r\n    if (apkFile.exists()) {\r\n      String suffixNew = target.equals(\"release\") ? \"release\" : \"debug\";\r\n      String apkNameNew = getPathToAPK() + \r\n        sketch.getName().toLowerCase() + \"_\" + suffixNew + \".apk\";\r\n      final File apkFileNew = new File(tmpFolder, apkNameNew);\r\n      apkFile.renameTo(apkFileNew);\r\n    }\r\n  }  \r\n  \r\n\r\n  private void removeKeyPassword() throws IOException {\r\n    File gradlePropsTemplate = mode.getContentFile(\"templates/\" + GRADLE_PROPERTIES_TEMPLATE);\r\n    File gradlePropsFile = new File(tmpFolder, \"gradle.properties\");\r\n    Util.copyFile(gradlePropsTemplate, gradlePropsFile);\r\n  }\r\n\r\n  \r\n  private String getPathToAPK() {\r\n    return module + \"/build/outputs/apk/\" + target + \"/\";\r\n  }\r\n  \r\n  \r\n  /**\r\n   * The Android dex util pukes on paths containing spaces, which will happen\r\n   * most of the time on Windows, since Processing sketches wind up in\r\n   * \"My Documents\". Therefore, build android in a temp file.\r\n   * http://code.google.com/p/android/issues/detail?id=4567\r\n   *\r\n   * @param sketch\r\n   * @return A folder in which to build the android sketch\r\n   * @throws IOException\r\n   */\r\n  private File createTempBuildFolder(final Sketch sketch) throws IOException {\r\n    final File tmp = File.createTempFile(\"android\", \"sketch\");\r\n    if (!(tmp.delete() && tmp.mkdir())) {\r\n      throw new IOException(AndroidMode.getTextString(\"android_build.error.cannot_create_build_folder\", tmp));\r\n    }\r\n    return tmp;\r\n  }\r\n  \r\n  \r\n  private void installGradlew(File exportFolder) throws IOException {\r\n    File gradlewFile = mode.getContentFile(\"mode/gradlew.zip\");\r\n    AndroidUtil.extractFolder(gradlewFile, exportFolder, false, false);\r\n    if (Platform.isMacOS() || Platform.isLinux()) {\r\n      File execFile = new File(exportFolder, \"gradlew\");    \r\n      execFile.setExecutable(true);      \r\n    }    \r\n  }\r\n  \r\n  \r\n  private File createExportFolder(String name) throws IOException {\r\n    return AndroidUtil.createSubFolder(sketch.getFolder(), name);\r\n  }  \r\n  \r\n  \r\n  static public void initVersions(File file) {    \r\n    InputStream input;\r\n    try {\r\n      input = new FileInputStream(file);\r\n      Properties props = new Properties();\r\n      props.load(input);\r\n      \r\n      MIN_SDK_APP = props.getProperty(\"android-min-app\");\r\n      MIN_SDK_WALLPAPER = props.getProperty(\"android-min-wallpaper\");        \r\n      MIN_SDK_VR = props.getProperty(\"android-min-vr\");\r\n      MIN_SDK_AR = props.getProperty(\"android-min-ar\");\r\n      MIN_SDK_WATCHFACE = props.getProperty(\"android-min-wear\");\r\n\r\n      // Versions strings of all dependencies are stored in a preferences file so they can be changed by the \r\n      // user without having to rebuild/reinstall the mode.\r\n\r\n      GRADLE_PLUGIN_VER = Preferences.get(\"android.gradle_plugin\");\r\n      String defGradlePluginVersion = props.getProperty(\"android-gradle-plugin\");\r\n      if (GRADLE_PLUGIN_VER == null || PApplet.parseInt(GRADLE_PLUGIN_VER) != PApplet.parseInt(defGradlePluginVersion)) {\r\n        GRADLE_PLUGIN_VER = defGradlePluginVersion;\r\n        Preferences.set(\"android.gradle_plugin\", GRADLE_PLUGIN_VER);\r\n      }\r\n      \r\n      TARGET_SDK = Preferences.get(\"android.sdk.target\");\r\n      String defTargetSDK = props.getProperty(\"android-platform\");\r\n      if (TARGET_SDK == null || PApplet.parseInt(TARGET_SDK) != PApplet.parseInt(defTargetSDK)) {\r\n        TARGET_SDK = defTargetSDK;\r\n        Preferences.set(\"android.sdk.target\", TARGET_SDK);\r\n      }\r\n\r\n      TARGET_WEAR_SDK_ARM = Preferences.get(\"android.sdk.target.wear_arm\");\r\n      String defTargetWearSDKArm = props.getProperty(\"android-platform-wear-arm\");\r\n      if (TARGET_WEAR_SDK_ARM == null || PApplet.parseInt(TARGET_WEAR_SDK_ARM) != PApplet.parseInt(defTargetWearSDKArm)) {\r\n        TARGET_WEAR_SDK_ARM = defTargetWearSDKArm;\r\n        Preferences.set(\"android.sdk.target.wear_arm\", TARGET_WEAR_SDK_ARM);\r\n      }\r\n\r\n      TARGET_WEAR_SDK = Preferences.get(\"android.sdk.target.wear\");\r\n      String defTargetWearSDK = props.getProperty(\"android-platform-wear\");\r\n      if (TARGET_WEAR_SDK == null || PApplet.parseInt(TARGET_WEAR_SDK) != PApplet.parseInt(defTargetWearSDK)) {\r\n        TARGET_WEAR_SDK = defTargetWearSDK;\r\n        Preferences.set(\"android.sdk.target.wear\", TARGET_WEAR_SDK);\r\n      }\r\n\r\n      APPCOMPAT_VER = Preferences.get(\"android.sdk.appcompat\");\r\n      String defAppCompatVer = props.getProperty(\"androidx.appcompat%appcompat\");\r\n      if (APPCOMPAT_VER == null || !versionCheck(APPCOMPAT_VER, defAppCompatVer)) {\r\n        APPCOMPAT_VER = defAppCompatVer;\r\n        Preferences.set(\"android.sdk.appcompat\", APPCOMPAT_VER);\r\n      }\r\n      \r\n      V4LEGACY_VER = Preferences.get(\"android.sdk.v4legacy\");\r\n      String defV4LegacyVer = props.getProperty(\"androidx.legacy%legacy-support-v4\");\r\n      if (V4LEGACY_VER == null || !versionCheck(V4LEGACY_VER, defV4LegacyVer)) {\r\n        V4LEGACY_VER = defV4LegacyVer;\r\n        Preferences.set(\"android.sdk.v4legacy\", V4LEGACY_VER);\r\n      }\r\n      \r\n      PLAY_SERVICES_VER = Preferences.get(\"android.sdk.play_services\");\r\n      String defPlayServicesVer = props.getProperty(\"com.google.android.gms%play-services-wearable\");\r\n      if (PLAY_SERVICES_VER == null || !versionCheck(PLAY_SERVICES_VER, defPlayServicesVer)) {\r\n        PLAY_SERVICES_VER = defPlayServicesVer;\r\n        Preferences.set(\"android.sdk.play_services\", PLAY_SERVICES_VER);\r\n      }\r\n      \r\n      WEAR_VER = Preferences.get(\"android.sdk.wear\");\r\n      String defWearVer = props.getProperty(\"com.google.android.support%wearable\");\r\n      if (WEAR_VER == null || !versionCheck(WEAR_VER, defWearVer)) {\r\n        WEAR_VER = defWearVer;\r\n        Preferences.set(\"android.sdk.wear\", WEAR_VER);\r\n      }\r\n      \r\n      GVR_VER = Preferences.get(\"android.sdk.gvr\");\r\n      String defVRVer = props.getProperty(\"com.google.vr\");\r\n      if (GVR_VER == null || !versionCheck(GVR_VER, defVRVer)) {\r\n        GVR_VER = defVRVer;\r\n        Preferences.set(\"android.sdk.gvr\", GVR_VER);\r\n      }        \r\n      \r\n      GAR_VER = Preferences.get(\"android.sdk.ar\");\r\n      String defARVer = props.getProperty(\"com.google.ar\");\r\n      if (GAR_VER == null || !versionCheck(GAR_VER, defARVer)) {\r\n        GAR_VER = defARVer;\r\n        Preferences.set(\"android.sdk.ar\", GAR_VER);\r\n      }        \r\n    } catch (FileNotFoundException e) {\r\n      e.printStackTrace();\r\n    } catch (IOException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n  \r\n  \r\n  static private boolean versionCheck(String currentVersion, String minVersion) {\r\n    String[] currentPieces = currentVersion.split(\"\\\\.\");\r\n    String[] minPieces = minVersion.split(\"\\\\.\");\r\n    \r\n    if (currentPieces.length == 3 && minPieces.length == 3) {\r\n      int currentMajor = PApplet.parseInt(currentPieces[0], -1);\r\n      int currentMinor = PApplet.parseInt(currentPieces[1], -1);\r\n      int currentMicro = PApplet.parseInt(currentPieces[2], -1);\r\n      \r\n      int minMajor = PApplet.parseInt(minPieces[0], -1);\r\n      int minMinor = PApplet.parseInt(minPieces[1], -1);\r\n      int minMicro = PApplet.parseInt(minPieces[2], -1);\r\n      \r\n      if (-1 < currentMajor && -1 < currentMinor && -1 < currentMicro &&\r\n          -1 < minMajor && -1 < minMinor && -1 < minMicro) {\r\n        if (currentMajor < minMajor) {\r\n          return false;\r\n        } else if (currentMajor == minMajor) {\r\n          if (currentMinor < minMinor) {\r\n            return false;  \r\n          } if (currentMinor == minMinor) {\r\n            if (currentMicro < minMicro) {\r\n              return false;\r\n            } else {\r\n              return true;\r\n            }\r\n          } else {\r\n            return true;\r\n          }\r\n        } else {\r\n          return true;\r\n        }\r\n      }      \r\n    }\r\n    \r\n    return false;\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/processing/mode/android/AndroidBuild.java b/src/processing/mode/android/AndroidBuild.java
--- a/src/processing/mode/android/AndroidBuild.java	(revision e81b5b41a9b360f8db31e3e9f672c68aae095546)
+++ b/src/processing/mode/android/AndroidBuild.java	(date 1696255826708)
@@ -440,7 +440,7 @@
     
     String modePath = new File(mode.getFolder(), "mode").getPath().replace('\\', '/');
     String toolPath = Base.getToolsFolder().getPath().replace('\\', '/');
-    String platformPath = sdk.getTargetPlatform(TARGET_SDK).getPath().replace('\\', '/');
+      String platformPath = sdk.getTargetPlatform(TARGET_SDK).getPath().replace('\\', '/');
     
     File appBuildTemplate = mode.getContentFile("templates/" + tmplFile);    
     File appBuildFile = new File(moduleFolder, "build.gradle");    
